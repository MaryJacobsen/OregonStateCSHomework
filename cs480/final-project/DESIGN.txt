CS 480 Final Project
Mary Jacobsen

To compile: make

To run without optimizations: make output.o or ./compiler < testing_code/p1.py

To run with optimizations: make optimize or ./compiler -O < testing_code/p1.py

I wasn't able to figure out how to write the C/C++ program that
calls the function generated by output.o. When I run make test,
it gives "undefined reference to output()" which is expected
because I didn't know how to get that.

ast.hpp sets up the classes for traversing the ast and includes
the needed libraries.

  ast.cpp implements all the classes and builds up the llvm function.
I put main in ast.cpp because it was easier to have access to the builder.
Before I had the builder initialized in ast.hpp and main in a separate file
which caused a segfault when main tried to access the builder. Then I tried
moving main to ast.cpp, that fixed the segfault.
  yylex() runs in main so the parser builds an ast and the Node pointer to the
root of the ast is called programBlock. ast.cpp traverses ast given by the
parser generating llvm even though I left the function called generateGVSpec.
The context gets passed in to the builder. The builder builds up the llvm
function. The module sort of holds everything based off how Professor Hess
described it in class. The context is also passed into the module. Each type
of node that the ast has has a class and a generateGVSpec function that
generates llvm code for that specific node. I only did the nodes necessary for
p1.py so I didn't handle any nodes that would require branching.
  Once each node had a function to generate llvm code, the function that returns
node->generateGVSpec(); can be called in main to recursively generate llvm code
for the whole ast. In main, first, the module is initialized. Then the
function type is retrieved. After getting the function type, the function is
created. Then the entry block is created and the builder's entry point is set
to the entry block. Then generateGVSpec is called on the root node from the
parser. The a void return type is created for the function. Then the function is
optimized if the "-O" option was used. Then the function is verified. Then the
module prints. Then the object code is generated to the filename "output.o" as
is specified in the assignment requirements. The we delete the module so there
aren't any memory leaks.
